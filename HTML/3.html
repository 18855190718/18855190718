<html>
<meta charset="UTF-8">
<!-- 宽度适应手机 -->
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no">
<link rel="stylesheet" type="text/css" href="../light/prism.css">

</audio>
<style>
    body {
        margin: 0;
        /* 字体 */
        font-family: 'Brush Script MT', cursive;
        background-color: bisque;
        background-size: 100% auto;
        background-repeat: no-repeat;
    }
    /* 导航栏 */
    
    ul {
        list-style-type: none;
        margin: 0;
        padding: 0;
        /* 宽度设置 */
        width: 15%;
        /* 透明颜色 */
        background: none;
        position: fixed;
        height: auto;
        overflow: auto;
    }
    
    li a {
        display: block;
        color: #000;
        padding: 0.5rem 1rem;
        text-decoration: none;
    }
    
    li a.active {
        background-color: #4CAF50;
        color: white;
    }
    
    li a:hover:not(.active) {
        background-color: #555;
        color: white;
    }
    /* 按钮 */
    
    .button {
        text-align: center;
        background-color: unset;
        text-decoration: none;
        display: inline-block;
        width: 100%;
        /* 字体大小 */
        font-size: 1.56rem;
        /* 字体颜色 */
        color: aqua;
        /* 圆角按钮 */
        border-radius: 0.75rem;
        cursor: pointer;
        -webkit-transition-duration: 0.4s;
        /* Safari */
        transition-duration: 0.4s;
    }
    
    .button:hover {
        box-shadow: 0 1.56rem 1rem 0 rgba(255, 255, 255, 0.24), 0 1.56rem 3.125rem 0 rgb(0, 0, 0);
    }
    
    .button:after {
        content: " ";
        background: #f1f1f1;
        display: block;
        position: absolute;
        padding-top: 5%;
        padding-left: 100%;
        margin-left: 0%;
        margin-top: 0%;
        opacity: 0;
        transition: all 0.3s
    }
    
    .button:active:after {
        padding: 0;
        margin: 0;
        opacity: 1;
        transition: 0s
    }
    /* 调整页面 */
    
    .leftBox,
    .rightBox {
        float: left;
        width: 20%;
        height: 500px;
        margin: 5px;
        background: #ffccf7;
        display: inline;
        -webkit-transition: width 1s ease;
        -moz-transition: width 1s ease;
        -o-transition: width 1s ease;
        -ms-transition: width 2s ease;
        transition: width 1s ease;
    }
    
    .middleBox {
        float: left;
        width: 50%;
        height: 800px;
        margin: 5px;
        background: #b1fffc;
        display: inline;
        -webkit-transition: width 1s ease;
        -moz-transition: width 1s ease;
        -o-transition: width 1s ease;
        -ms-transition: width 1s ease;
        transition: width 1s ease;
    }
    
    .rightBox {
        background: #fffab1;
    }
    /* 分辨率判断 */
    
    @media only screen and (min-width: 1024px) {
        .content {
            width: 1000px;
            margin: auto
        }
    }
    
    @media only screen and (min-width: 400px) and (max-width: 1024px) {
        .rightBox {
            width: 0;
        }
        .leftBox {
            width: 30%
        }
        .middleBox {
            width: 65%
        }
    }
    
    @media only screen and (max-width: 400px) {
        .leftBox,
        .rightBox,
        .middleBox {
            width: 98%;
            height: 200px;
        }
    }
    /*视频背景 */
    
    * {
        margin: 0px;
        padding: 0px;
    }
    
    video {
        position: fixed;
        right: 0px;
        bottom: 0px;
        min-width: 100%;
        min-height: 100%;
        height: 100%;
        width: auto;
        /*加滤镜*/
        /*filter: blur(15px); //背景模糊设置 */
        /*-webkit-filter: grayscale(100%);*/
        /*filter:grayscale(100%); //背景灰度设置*/
        z-index: -1
    }
    
    source {
        min-width: 100%;
        min-height: 100%;
        height: auto;
        width: 100%;
    }
    
    p {
        width: 100%;
        text-align: center;
        font-size: 40px;
        color: white;
    }
</style>
<!-- 图片自适应 -->

<head>
    <meta charset="UTF-8 ">
    <link href="../CSS/1.css " rel="stylesheet " type="text/css ">

    <video autoplay="autoplay" loop="loop" muted="muted">
        <source src="../视频/老婆.mp4" type="video/mp4" />
        <audio src="../音乐/老婆.mp3" autoplay="autoplay " loop="loop "></audio>
    </video>
</head>

<body>
   
    <ul style="top: 60;">
        <li>
            <a class="active" href="#0">回到顶部</a>
        </li>
        <li><a href="#1 ">实验一</a></li>
        <li><a href="#2 ">实验二</a></li>
        <li><a href="#3 ">实验三</a></li>
        <li><a href="#4 ">实验四</a></li>
        <li><a href="#5 ">实验五</a></li>
    </ul>
    <div class="charset_title" style="margin-top: 20%;" id="0"> 无名之逆的博客
    </div>
    <div style="text-align: center;padding-top: 12%">
        <a href="https://blog.csdn.net/m0_52796585?spm=1000.2115.3001.5343 " class="link_c_l_blue">C S D N博客链接</a>
    </div>
    <br>
    <a href="#1">
        <button class="button ">开始</button>
    </a>
    
    <div style="margin-left:25%;padding:1px 16px;height:auto;width: auto;">
        <!-- 还要注意，我们已为 sidenav 设置 overflow：auto。如果 sidenav 太长时（例如，如果其中有超过 50 个链接），会添加滚动条。 -->
        <!-- 请注意，此 div 元素的左外边距为 25％。这是因为侧导航栏被设置为 25％ 宽。如果删除这个外边距，则 sidenav 将叠加到该 div 上。 -->
        <!-- 全高的固定侧导航栏 -->
        <!-- 请尝试滚动此区域，并查看 sidenav 如何粘在页面上。 -->

        <h1 style="color: cyan; " id="1">实验一：多项式相加</h1>
        <pre style="color: rgb(13, 190, 108);font-size: 1.2rem;">
    一、实验名称：多项式相加 
    二、实验学时：4学时 
    三、实验目的 
        1.理解单链表的结构特性和基本操作算法； 
        2.掌握利用单链表实现两个多项式相加算法。 
    四、实验内容(步骤) 
        1.创建两个一元多项式； 
        2.输出一元多项式； 3.实现两个一元多项式相加； 
        4.输出相加后的一元多项式。
        </pre>
        <pre>
<code class="language-cpp" >
    #include&lt;iostream&gt;
    using namespace std;
    struct list{
        double val;
        int index;
        list *next;
    };
    void creat(list* head){
        list *p,*q;
        p=head;
        q=nullptr;
        while(1){
            int val(0),index(0);
            cin>>val>>index;
            if(val==-1) return;
            q=(list*)malloc(sizeof(list));
            q->next=nullptr;
            q->val=val;
            q->index=index;
            p->next=q;
            p=q;
        }
    }
    void print(list *head){
        if(head==nullptr||head->next==nullptr) return;
        list *p=head->next;
        while(p->next!=nullptr){
            printf("%0.3f*X^%d",p->val,p->index);
            if(p->val>0) cout<<"+";
            p=p->next;
        }
        printf("%0.3f*X^%d",p->val,p->index);
    }
    list* sum(list *head1,list *head2){
        if(head1->next==nullptr&&head2->next==nullptr) return nullptr;
        list *p1_n=head1->next,*p2_n=head2->next,*head3=new list,*p3=head3,*q3=head3;
        p3->next=nullptr;
        while(p1_n!=nullptr&&p2_n!=nullptr){
            if(p1_n->index==p2_n->index){
                if(!(p1_n->val+p2_n->val)){
                    p1_n=p1_n->next;
                    p2_n=p2_n->next;
                }
                else{
                    p3=(struct list*)malloc(sizeof(list));
                    p3->next=nullptr;
                    p3->val=p1_n->val+p2_n->val;
                    p3->index=p1_n->index;
                    q3->next=p3;
                    q3=p3;
                    p1_n=p1_n->next;
                    p2_n=p2_n->next;
                }
            }
            else if(p1_n->index&lt;p2_n->index){
                if(p1_n->val!=0){
                    p3=(struct list*)malloc(sizeof(list));
                    p3->next=nullptr;
                    p3->val=p1_n->val;
                    p3->index=p1_n->index;
                    q3->next=p3;
                    q3=p3;
                    p1_n=p1_n->next;
                }
                else {
                    p1_n=p1_n->next;
                } 
                
            }
            else if(p1_n->index>p2_n->index){
                if(p2_n->val!=0){
                        p3=(struct list*)malloc(sizeof(list));
                        p3->next=nullptr;
                        p3->val=p2_n->val;
                        p3->index=p2_n->index;
                        q3->next=p3;
                        q3=p3;
                        p2_n=p2_n->next;
                }
                else {
                    p2_n=p2_n->next;
                }
            }
        }
        if(p1_n==nullptr&&p2_n!=nullptr){
            p3->next=p2_n;
            while(p2_n!=nullptr){
                if(p2_n->val==0){
                    p3->next=p2_n->next;
                    free(p2_n);
                    p2_n=p3->next;
                }
                else {
                    p3=p3->next;
                    p2_n=p3->next;
                }
            }
            return head3;
        }
        else if(p1_n!=nullptr&&p2_n==nullptr){
            p3->next=p1_n;
            while(p1_n!=nullptr){
                if(p1_n->val==0){
                    p3->next=p1_n->next;
                    free(p1_n);
                    p1_n=p3->next;
                }
                else {
                    p3=p3->next;
                    p1_n=p3->next;
                }
            }
            return head3;
        }
        else return head3;
    }
    int main(){
        while(1){
            list *head1;
            head1=(struct list*)malloc(sizeof(list));
            head1->next=nullptr;
            cout<<"输入第一个表达式：";
            creat(head1);
        
            list *head2;
            head2=(struct list*)malloc(sizeof(list));
            head2->next=nullptr;
            cout<<"输入第二个表达式：";
            creat(head2);
        
            head1=sum(head1,head2);
            cout<<"输出合并后的表达式：";
            print(head1);
            cout&lt;&lt;endl;
        }
        return 0;
    }
</code>
</div>
<div style="margin-left:25%;padding:1px 16px;height:auto;width: auto;">
    <!-- 还要注意，我们已为 sidenav 设置 overflow：auto。如果 sidenav 太长时（例如，如果其中有超过 50 个链接），会添加滚动条。 -->
    <!-- 请注意，此 div 元素的左外边距为 25％。这是因为侧导航栏被设置为 25％ 宽。如果删除这个外边距，则 sidenav 将叠加到该 div 上。 -->
    <!-- 全高的固定侧导航栏 -->
    <!-- 请尝试滚动此区域，并查看 sidenav 如何粘在页面上。 -->

    <h1 style="color: cyan; " id="2">实验2  表达式求值</h1>
    <pre style="color: rgb(13, 190, 108);font-size: 1.2rem;">
    二、实验学时：
        6学时
    三、实验目的
        1.理解栈的结构特点和基本操作特性；
        2.掌握利用栈实现表达式求值算法。 
    四、实验内容(步骤)
        输入一个算术表达式(以“=”结束)，求其值。要求表达式以“=”结束，操作数为多位实数，对错误表达式要进行检测。
        1.设置两个栈：optr算符栈和opnd操作数栈。初始置opnd为空栈；起始符“=”为optr的栈底元素；
        2.自左向右扫描表达式中的每个字符c：
        1)若c为操作数，则进opnd栈；
        2)若c为算符，则让optr栈的栈顶元素与c比较优先级：
        a.若栈顶算符优先级低于刚读入的运算符c，则让刚读入的运算符c进optr栈。
        b.若栈顶算符优先级高于刚读入的运算符c，则将栈顶算符退栈，送入；同时将操作数栈opnd退栈两次，得到两个操作数b、a，对a、b进行ab运算后，将运算结果作为中间结果推入opnd栈。
        c.若栈顶运算符的优先级与刚读入的运算符c相同，说明左右括号相遇，只需将栈顶运算符（左括号）退栈即可。
        3.直到扫描到c为定界符，即optr栈的栈顶元素和当前读入的字符均为“=”，则整个表达式求值完毕。
    </pre>
    <pre style="color: aqua;">


    </pre>
    <pre>
<code class="language-cpp">
    #include&lt;iostream>
    #include&lt;string>
    #include&lt;stdlib.h>
    #include&lt;algorithm>
    #include&lt;math.h>
    using namespace std;
    template &lt;class vector> class stack{
        public:
            int top;
            vector a[100];//数组模拟栈
            stack(){
                top=0;
            }
            //栈空判断
            bool Empty(){
                return top==0?true:false;
            }
            //栈的上限判断
            bool MaxSize(){
                return top>=99?true:false;
            }
            //入栈
            template &lt;typename t> void Push_Back(t tem){
                if(MaxSize()) return;
                ++top;
                a[top]=tem;
            }
            //出栈
            vector Pop_back(){
                if(Empty()) return 0;
                vector tem=a[top];
                --top;
                return tem;
            }
            //获取顶部元素
            vector TopNum(){
                return a[top];
            }
            //清空数组
            void clear(){
                top=0;
            }
    };
    //转double型数字
    double word(int &i,string s){
        double tem(0);
        double res(0);
        long long int sign(1);
        int SumNum(-1);
        int point(0);
        for(int j=i;(s[j]<='9'&&s[j]>='0'&&j&lt;s.size())||s[j]=='.';++j){
            ++SumNum;
            if(s[j]=='.'){
                point=j-i;
                --SumNum;
            }
        }
        sign=pow(10,SumNum)+0.000001;
        while(sign){
            if(s[i]=='.'){
                ++i;
                continue;
            }
            tem+=(s[i]-'0')*sign;
            ++i;
            sign/=10;
        }
        --i;
        if(point!=0) res=tem/(pow(10,SumNum-point+1)+0.000001);
        else res=tem;
        return res;
    }
    //入栈符号判断
    bool JudgeChar(char tem){
        if(tem=='+'||tem=='-'||tem=='*'||tem=='/'||tem=='('||tem==')') return true;
        else return false;
    }
    //优先级判断
    char FirSec(char c1, char c2){
        if(c2=='=') return '>';
    
        if(c1=='+'){
            if(c2=='+') return '=';
            else if(c2=='-') return '=';
            else if(c2=='*') return '<';
            else if(c2=='/') return '<';
            else if(c2=='(') return '>';
        }
        else if(c1=='-'){
            if(c2=='+') return '=';
            else if(c2=='-') return '=';
            else if(c2=='*') return '<';
            else if(c2=='/') return '<';
            else if(c2=='(') return '>';
        }
        else if(c1=='*'){
            if(c2=='+') return '>';
            else if(c2=='-') return '>';
            else if(c2=='*') return '=';
            else if(c2=='/') return '=';
            else if(c2=='(') return '>';
        }
        else if(c1=='/'){
            if(c2=='+') return '>';
            else if(c2=='-') return '>';
            else if(c2=='*') return '=';
            else if(c2=='/') return '=';
            else if(c2=='(') return '>';
        }
        else if(c1=='('){
            if(c2=='+') return '>';
            else if(c2=='-') return '>';
            else if(c2=='*') return '>';
            else if(c2=='/') return '>';
            else if(c2=='(') return '>';
        }
        return '=';
    }
    //计算部分
    double Calculation(string str,stack&lt;char> ShengQiangShi,stack&lt;double> math){
        char c('0');
        double n1(0),n2(0);
        for(int i=0;i&lt;str.size();++i){
            if(str[i]=='=') continue;
            if(JudgeChar(str[i])){
                if(str[i]==')'){
                    c=ShengQiangShi.Pop_back();
                    while(c != '('){
                        n1=math.Pop_back();
                        n2=math.Pop_back();
                        switch(c){
                            case '+': math.Push_Back(n2+n1);break;
                            case '-': math.Push_Back(n2-n1);break;
                            case '*': math.Push_Back(n2*n1);break;
                            case '/': math.Push_Back(n2/n1);break;
                        }   
                        c=ShengQiangShi.Pop_back();//弹出运算符号
                    }
                }
                else if(FirSec(str[i],ShengQiangShi.TopNum())=='>'){
                    ShengQiangShi.Push_Back(str[i]);
                }
                else{
                    while(FirSec(str[i],ShengQiangShi.TopNum())!='>'||str[i]=='='){
                        c=ShengQiangShi.Pop_back();
                        n1=math.Pop_back();
                        n2=math.Pop_back();
                        switch(c){
                            case '+': math.Push_Back(n2+n1);break;
                            case '-': math.Push_Back(n2-n1);break;
                            case '*': math.Push_Back(n2*n1);break;
                            case '/': math.Push_Back(n2/n1);break;
                            default:break;
                        }
                    }
                    ShengQiangShi.Push_Back(str[i]);
                }
            }   
            else{
                math.Push_Back(word(i,str));
            }
        }
        c=ShengQiangShi.Pop_back();
        while(c!='='){
            switch(c){
                case '+':n1=math.Pop_back();n2=math.Pop_back();math.Push_Back(n2+n1);break;
                case '-':n1=math.Pop_back();n2=math.Pop_back();math.Push_Back(n2-n1);break;
                case '*':n1=math.Pop_back();n2=math.Pop_back();math.Push_Back(n2*n1);break;
                case '/':n1=math.Pop_back();n2=math.Pop_back();math.Push_Back(n2/n1);break;
                default:break;
            }
            c=ShengQiangShi.Pop_back();
        }
        return math.TopNum();
    } 
    int main(){
        stack&lt;double> ShengQiangShi;
        stack&lt;double> math;
        string str;
        while(1){
            ShengQiangShi.Push_Back('=');
            cin>>str;
            cout&lt;&lt;Calculation(str,ShengQiangShi,math)&lt;&lt;endl;
            ShengQiangShi.clear();
            math.clear();
        }
        return 0;
    }
    
</code>
</pre>
        <script src="../light/prism.js"></script>
</div>




</body>

</html>
