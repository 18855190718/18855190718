<html>
<meta charset="UTF-8">
<!-- 宽度适应手机 -->
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no">
<link rel="stylesheet" type="text/css" href="../light/prism.css">
<audio src=" ../音乐/The truth that you leave.mp3 - 溯（治愈女声版）.mp3" autoplay="autoplay " loop="loop ">
</audio>
<style>
    /* body {
        margin: 0;
        background-image: url(../照片/质感4K（1）.png);
        background-size: 100% auto;
        background-repeat: no-repeat;
        background-color: bisque; 
}
*/
    /* 导航栏 */
    
    ul {
        list-style-type: none;
        margin: 0;
        padding: 0;
        /* 宽度设置 */
        width: 15%;
        /* 透明颜色 */
        background: none;
        position: fixed;
        height: auto;
        overflow: auto;
    }
    
    li a {
        display: block;
        color: #000;
        padding: 0.5rem 1rem;
        text-decoration: none;
    }
    
    li a.active {
        background-color: #4CAF50;
        color: white;
    }
    
    li a:hover:not(.active) {
        background-color: #555;
        color: white;
    }
    /* 按钮 */
    
    .button {
        text-align: center;
        background-color: unset;
        text-decoration: none;
        display: inline-block;
        width: 100%;
        /* 字体大小 */
        font-size: 1.56rem;
        /* 字体颜色 */
        color: aqua;
        /* 圆角按钮 */
        border-radius: 0.75rem;
        cursor: pointer;
        -webkit-transition-duration: 0.4s;
        /* Safari */
        transition-duration: 0.4s;
    }
    
    .button:hover {
        box-shadow: 0 1.56rem 1rem 0 rgba(255, 255, 255, 0.24), 0 1.56rem 3.125rem 0 rgb(0, 0, 0);
    }
    
    .button:after {
        content: " ";
        background: #f1f1f1;
        display: block;
        position: absolute;
        padding-top: 5%;
        padding-left: 100%;
        margin-left: 0%;
        margin-top: 0%;
        opacity: 0;
        transition: all 0.3s
    }
    
    .button:active:after {
        padding: 0;
        margin: 0;
        opacity: 1;
        transition: 0s
    }
    /* 调整页面 */
    
    .leftBox,
    .rightBox {
        float: left;
        width: 20%;
        height: 500px;
        margin: 5px;
        background: #ffccf7;
        display: inline;
        -webkit-transition: width 1s ease;
        -moz-transition: width 1s ease;
        -o-transition: width 1s ease;
        -ms-transition: width 2s ease;
        transition: width 1s ease;
    }
    
    .middleBox {
        float: left;
        width: 50%;
        height: 800px;
        margin: 5px;
        background: #b1fffc;
        display: inline;
        -webkit-transition: width 1s ease;
        -moz-transition: width 1s ease;
        -o-transition: width 1s ease;
        -ms-transition: width 1s ease;
        transition: width 1s ease;
    }
    
    .rightBox {
        background: #fffab1;
    }
    /* 分辨率判断 */
    
    @media only screen and (min-width: 1024px) {
        .content {
            width: 1000px;
            margin: auto
        }
    }
    
    @media only screen and (min-width: 400px) and (max-width: 1024px) {
        .rightBox {
            width: 0;
        }
        .leftBox {
            width: 30%
        }
        .middleBox {
            width: 65%
        }
    }
    
    @media only screen and (max-width: 400px) {
        .leftBox,
        .rightBox,
        .middleBox {
            width: 98%;
            height: 200px;
        }
    }
    /*视频背景 */
    
    * {
        margin: 0px;
        padding: 0px;
    }
    
    video {
        position: fixed;
        right: 0px;
        bottom: 0px;
        min-width: 100%;
        min-height: 100%;
        height: auto;
        width: 100%;
        /*加滤镜*/
        /*filter: blur(15px); //背景模糊设置 */
        /*-webkit-filter: grayscale(100%);*/
        /*filter:grayscale(100%); //背景灰度设置*/
        z-index: -11
    }
    
    source {
        min-width: 100%;
        min-height: 100%;
        height: auto;
        width: 100%;
    }
    
    p {
        width: 100%;
        text-align: center;
        font-size: 40px;
        color: white;
    }
</style>
<!-- 图片自适应 -->
<script>
    addLoadEvent(function() {
        var imgs = document.getElementById("content ").getElementsByTagName("img ");
        imgSizer.collate(imgs);
    });
    addLoadEvent();
</script>

<head>
    <meta charset="UTF-8 ">
    <link href="../CSS/1.css " rel="stylesheet " type="text/css ">
    <div class="charset_title">
        无名之逆的博客
    </div>

</head>

<body>
    <video autoplay loop muted>
        <source src="E:\焰灵姬.mp4" type="video/mp4" />
    </video>
    <ul>
        <li>
            <a class="active" href="#0">回到顶部</a>
        </li>
        <li><a href="#1 ">实验一</a></li>
        <li><a href="#2 ">实验二</a></li>
        <li><a href="#3 ">实验三</a></li>
        <li><a href="#4 ">实验四</a></li>
        <li><a href="#5 ">实验五</a></li>
    </ul>

    <div style="text-align: center;padding-top: 38%">
        <a href="https://blog.csdn.net/m0_52796585?spm=1000.2115.3001.5343 " class="link_c_l_blue">CSDN博客链接</a>
    </div>
    <br>
    <a href="#2">
        <button class="button ">开始</button>
    </a>
    <div style="margin-left:25%;padding:1px 16px;height:auto;width: auto;" id="1">
        <!-- 还要注意，我们已为 sidenav 设置 overflow：auto。如果 sidenav 太长时（例如，如果其中有超过 50 个链接），会添加滚动条。 -->
        <!-- 请注意，此 div 元素的左外边距为 25％。这是因为侧导航栏被设置为 25％ 宽。如果删除这个外边距，则 sidenav 将叠加到该 div 上。 -->
        <!-- 全高的固定侧导航栏 -->
        <!-- 请尝试滚动此区域，并查看 sidenav 如何粘在页面上。 -->

        <h1 style="color: cyan; ">实验一：多项式相加</h1>
        <pre style="color: rgb(13, 190, 108);font-size: 1.2rem;">
    一、实验名称：多项式相加 
    二、实验学时：4学时 
    三、实验目的 
        1.理解单链表的结构特性和基本操作算法； 
        2.掌握利用单链表实现两个多项式相加算法。 
    四、实验内容(步骤) 
        1.创建两个一元多项式； 
        2.输出一元多项式； 3.实现两个一元多项式相加； 
        4.输出相加后的一元多项式。
        </pre>
        <pre>
<code class="language-css">
    #include<iostream>
    using namespace std;
    struct list{
        double val;
        int index;
        list *next;
    };
    void creat(list* head){
        list *p,*q;
        p=head;
        q=nullptr;
        while(1){
            int val(0),index(0);
            cin>>val>>index;
            if(val==-1) return;
            q=(list*)malloc(sizeof(list));
            q->next=nullptr;
            q->val=val;
            q->index=index;
            p->next=q;
            p=q;
        }
    }
    void print(list *head){
        if(head==nullptr||head->next==nullptr) return;
        list *p=head->next;
        while(p->next!=nullptr){
            printf("%0.3f*X^%d",p->val,p->index);
            if(p->val>0) cout<<"+";
            p=p->next;
        }
        printf("%0.3f*X^%d",p->val,p->index);
    }
    list* sum(list *head1,list *head2){
        if(head1->next==nullptr&&head2->next==nullptr) return nullptr;
        list *p1_n=head1->next,*p2_n=head2->next,*head3=new list,*p3=head3,*q3=head3;
        p3->next=nullptr;
        while(p1_n!=nullptr&&p2_n!=nullptr){
            if(p1_n->index==p2_n->index){
                if(!(p1_n->val+p2_n->val)){
                    p1_n=p1_n->next;
                    p2_n=p2_n->next;
                }
                else{
                    p3=(struct list*)malloc(sizeof(list));
                    p3->next=nullptr;
                    p3->val=p1_n->val+p2_n->val;
                    p3->index=p1_n->index;
                    q3->next=p3;
                    q3=p3;
                    p1_n=p1_n->next;
                    p2_n=p2_n->next;
                }
            }
            else if(p1_n->index<p2_n->index){
                if(p1_n->val!=0){
                    p3=(struct list*)malloc(sizeof(list));
                    p3->next=nullptr;
                    p3->val=p1_n->val;
                    p3->index=p1_n->index;
                    q3->next=p3;
                    q3=p3;
                    p1_n=p1_n->next;
                }
                else {
                    p1_n=p1_n->next;
                } 
                
            }
            else if(p1_n->index>p2_n->index){
                if(p2_n->val!=0){
                        p3=(struct list*)malloc(sizeof(list));
                        p3->next=nullptr;
                        p3->val=p2_n->val;
                        p3->index=p2_n->index;
                        q3->next=p3;
                        q3=p3;
                        p2_n=p2_n->next;
                }
                else {
                    p2_n=p2_n->next;
                }
            }
        }
        if(p1_n==nullptr&&p2_n!=nullptr){
            p3->next=p2_n;
            while(p2_n!=nullptr){
                if(p2_n->val==0){
                    p3->next=p2_n->next;
                    free(p2_n);
                    p2_n=p3->next;
                }
                else {
                    p3=p3->next;
                    p2_n=p3->next;
                }
            }
            return head3;
        }
        else if(p1_n!=nullptr&&p2_n==nullptr){
            p3->next=p1_n;
            while(p1_n!=nullptr){
                if(p1_n->val==0){
                    p3->next=p1_n->next;
                    free(p1_n);
                    p1_n=p3->next;
                }
                else {
                    p3=p3->next;
                    p1_n=p3->next;
                }
            }
            return head3;
        }
        else return head3;
    }
    int main(){
        while(1){
            list *head1;
            head1=(struct list*)malloc(sizeof(list));
            head1->next=nullptr;
            cout<<"输入第一个表达式：";
            creat(head1);
        
            list *head2;
            head2=(struct list*)malloc(sizeof(list));
            head2->next=nullptr;
            cout<<"输入第二个表达式：";
            creat(head2);
        
            head1=sum(head1,head2);
            cout<<"输出合并后的表达式：";
            print(head1);
            cout<<endl;
        }
        return 0;
    }
</code>

        </pre> //
        <script src="../light/prism.js"></script>
    </div>

    <pre id="2">
        <code class="language-css">

        </code>
    </pre>

    <pre id="3">
        <code class="language-css">

        </code>
    </pre>

    <pre id="4">
        <code class="language-css">

        </code>
    </pre>

    <pre id="5">
        <code class="language-css">

        </code>
    </pre>



</body>

</html>